{"version":3,"sources":["../src/services/chat.ts","../src/client.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import type {\n  EternalAIConfig,\n  ChatCompletionRequest,\n  ChatCompletionStreamingRequest,\n  ChatCompletionNonStreamingRequest,\n  ChatCompletionChunk,\n  ChatCompletionResponse,\n} from '../types';\n\n/**\n * Chat service for sending messages and receiving responses\n */\nexport class Chat {\n  private readonly config: EternalAIConfig;\n  private readonly baseUrl = 'https://open.eternalai.org/api/v1';\n\n  constructor(config: EternalAIConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Send a streaming chat completion request\n   * @param request - Chat completion request with stream: true, and optional image_config for image generation models\n   * @returns Async iterable of chat completion chunks\n   */\n  send(request: ChatCompletionStreamingRequest): Promise<AsyncIterable<ChatCompletionChunk>>;\n\n  /**\n   * Send a non-streaming chat completion request\n   * @param request - Chat completion request with stream: false or undefined, and optional image_config for image generation models\n   * @returns Chat completion response\n   */\n  send(request: ChatCompletionNonStreamingRequest): Promise<ChatCompletionResponse>;\n\n  /**\n   * Send a chat completion request\n   * @param request - Chat completion request with messages, model, stream option, and optional image_config for image generation models\n   * @returns Async iterable of chat completion chunks (if streaming) or single response\n   */\n  send(\n    request: ChatCompletionRequest\n  ): Promise<AsyncIterable<ChatCompletionChunk> | ChatCompletionResponse>;\n\n  /**\n   * Implementation of send method\n   */\n  async send(\n    request: ChatCompletionRequest\n  ): Promise<AsyncIterable<ChatCompletionChunk> | ChatCompletionResponse> {\n    const url = `${this.baseUrl}/chat/completions`;\n    const headers = {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${this.config.apiKey}`,\n    };\n\n    const body = JSON.stringify(request);\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body,\n      signal: this.createAbortSignal(),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`EternalAI request failed with status ${response.status}: ${errorText}`);\n    }\n\n    if (request.stream) {\n      // Check if body is readable before returning async iterable\n      if (!response.body) {\n        throw new Error('Response body is not readable');\n      }\n      return this.handleStreamingResponse(response);\n    } else {\n      return (await response.json()) as ChatCompletionResponse;\n    }\n  }\n\n  /**\n   * Create abort signal with timeout\n   */\n  private createAbortSignal(): AbortSignal | undefined {\n    if (this.config.timeout) {\n      const controller = new AbortController();\n      setTimeout(() => controller.abort(), this.config.timeout);\n      return controller.signal;\n    }\n    return undefined;\n  }\n\n  /**\n   * Handle streaming response using Server-Sent Events\n   */\n  private async *handleStreamingResponse(response: Response): AsyncIterable<ChatCompletionChunk> {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          const trimmedLine = line.trim();\n          if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n            continue;\n          }\n\n          if (trimmedLine.startsWith('data: ')) {\n            const data = trimmedLine.slice(6);\n            try {\n              const chunk = JSON.parse(data) as ChatCompletionChunk;\n              yield chunk;\n            } catch (error) {\n              // Silently skip invalid JSON chunks to maintain stream continuity\n              // In production, invalid chunks are typically malformed SSE data\n            }\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\n","import { Chat } from './services/chat';\nimport type { EternalAIConfig } from './types';\n\nexport class EternalAI {\n  public readonly chat: Chat;\n  private readonly config: EternalAIConfig;\n\n  constructor(config: EternalAIConfig) {\n    if (!config.apiKey) {\n      throw new Error('API key is required');\n    }\n    this.config = config;\n    this.chat = new Chat(this.config);\n  }\n}\n"]}
{"version":3,"sources":["../src/services/nano-banana.ts","../src/services/tavily.ts","../src/services/chat.ts","../src/client.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n    ChatCompletionChunk,\n    ChatCompletionResponse,\n} from '../types';\n\n/**\n * Response from Gemini-style API\n */\ninterface GeminiPart {\n    text?: string;\n    inlineData?: {\n        mimeType: string;\n        data: string; // base64 encoded\n    };\n}\n\ninterface GeminiCandidate {\n    content: {\n        parts: GeminiPart[];\n        role: string;\n    };\n    finishReason: string;\n}\n\ninterface GeminiResponse {\n    candidates: GeminiCandidate[];\n    usageMetadata?: {\n        promptTokenCount: number;\n        candidatesTokenCount: number;\n        totalTokenCount: number;\n    };\n}\n\n/**\n * NanoBanana service for custom endpoint models\n * Transforms OpenAI-style requests to Google Gemini format\n */\nexport class NanoBanana {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/nano-banana/v1beta/models';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Generate content using nano-banana endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param geminiModel - The Gemini model to use (default: gemini-2.5-flash-image)\n     * @returns Chat completion response in OpenAI format\n     */\n    async generateContent(\n        request: ChatCompletionRequest,\n        geminiModel: string = 'gemini-2.5-flash-image'\n    ): Promise<ChatCompletionResponse> {\n        const url = `${this.baseUrl}/${geminiModel}:generateContent`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'x-goog-api-key': this.config.apiKey,\n        };\n\n        // Transform OpenAI format to Gemini format\n        const geminiBody = this.transformToGeminiFormat(request);\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(geminiBody),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`NanoBanana request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const geminiResponse = (await response.json()) as GeminiResponse;\n\n        // Transform Gemini response back to OpenAI format\n        return this.transformToOpenAIFormat(geminiResponse, geminiModel);\n    }\n\n    /**\n     * Generate image content using nano-banana endpoint\n     * @param prompt - Text prompt for image generation\n     * @param geminiModel - The Gemini model to use (default: gemini-2.5-flash-image)\n     * @returns Base64 encoded image data or null if no image in response\n     */\n    async generateImage(\n        prompt: string,\n        geminiModel: string = 'gemini-2.5-flash-image'\n    ): Promise<{ mimeType: string; data: string } | null> {\n        const url = `${this.baseUrl}/${geminiModel}:generateContent`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'x-goog-api-key': this.config.apiKey,\n        };\n\n        const geminiBody = {\n            contents: [{\n                parts: [{ text: prompt }]\n            }]\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(geminiBody),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`NanoBanana request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const geminiResponse = (await response.json()) as GeminiResponse;\n\n        // Extract image from response\n        for (const candidate of geminiResponse.candidates || []) {\n            for (const part of candidate.content?.parts || []) {\n                if (part.inlineData) {\n                    return {\n                        mimeType: part.inlineData.mimeType,\n                        data: part.inlineData.data,\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Stream content using nano-banana endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param geminiModel - The Gemini model to use\n     * @returns Async iterable of chat completion chunks\n     */\n    async *streamContent(\n        request: ChatCompletionRequest,\n        geminiModel: string = 'gemini-2.5-flash-image'\n    ): AsyncIterable<ChatCompletionChunk> {\n        const url = `${this.baseUrl}/${geminiModel}:streamGenerateContent?alt=sse`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'x-goog-api-key': this.config.apiKey,\n        };\n\n        // Transform OpenAI format to Gemini format\n        const geminiBody = this.transformToGeminiFormat(request);\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(geminiBody),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`NanoBanana streaming request failed with status ${response.status}: ${errorText}`);\n        }\n\n        if (!response.body) {\n            throw new Error('Response body is not readable');\n        }\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n        let chunkId = `chatcmpl-${Date.now()}`;\n\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || '';\n\n                for (const line of lines) {\n                    const trimmedLine = line.trim();\n                    if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n                        continue;\n                    }\n\n                    if (trimmedLine.startsWith('data: ')) {\n                        const data = trimmedLine.slice(6);\n                        try {\n                            const geminiChunk = JSON.parse(data) as GeminiResponse;\n\n                            // Transform to OpenAI chunk format\n                            const content = geminiChunk.candidates?.[0]?.content?.parts?.[0]?.text || '';\n                            const finishReason = geminiChunk.candidates?.[0]?.finishReason;\n\n                            const chunk: ChatCompletionChunk = {\n                                id: chunkId,\n                                object: 'chat.completion.chunk',\n                                created: Math.floor(Date.now() / 1000),\n                                model: geminiModel,\n                                choices: [{\n                                    index: 0,\n                                    delta: { content },\n                                    finish_reason: finishReason === 'STOP' ? 'stop' : null,\n                                }],\n                            };\n\n                            yield chunk;\n                        } catch {\n                            // Skip invalid JSON\n                        }\n                    }\n                }\n            }\n        } finally {\n            reader.releaseLock();\n        }\n    }\n\n    /**\n     * Transform OpenAI format request to Gemini format\n     */\n    private transformToGeminiFormat(request: ChatCompletionRequest): object {\n        const contents: { role: string; parts: { text: string }[] }[] = [];\n\n        for (const message of request.messages) {\n            // Map OpenAI roles to Gemini roles\n            let role = 'user';\n            if (message.role === 'assistant') {\n                role = 'model';\n            } else if (message.role === 'system') {\n                // Gemini doesn't have system role, prepend to first user message\n                // For now, treat as user\n                role = 'user';\n            }\n\n            contents.push({\n                role,\n                parts: [{ text: message.content }],\n            });\n        }\n\n        return { contents };\n    }\n\n    /**\n     * Transform Gemini response to OpenAI format\n     */\n    private transformToOpenAIFormat(\n        geminiResponse: GeminiResponse,\n        model: string\n    ): ChatCompletionResponse {\n        const candidate = geminiResponse.candidates?.[0];\n        const content = candidate?.content?.parts?.map(p => p.text || '').join('') || '';\n\n        return {\n            id: `chatcmpl-${Date.now()}`,\n            object: 'chat.completion',\n            created: Math.floor(Date.now() / 1000),\n            model,\n            choices: [{\n                index: 0,\n                message: {\n                    role: 'assistant',\n                    content,\n                },\n                finish_reason: candidate?.finishReason === 'STOP' ? 'stop' : null,\n            }],\n            usage: geminiResponse.usageMetadata ? {\n                prompt_tokens: geminiResponse.usageMetadata.promptTokenCount,\n                completion_tokens: geminiResponse.usageMetadata.candidatesTokenCount,\n                total_tokens: geminiResponse.usageMetadata.totalTokenCount,\n            } : undefined,\n        };\n    }\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n}\n","import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n    ChatCompletionResponse,\n} from '../types';\n\n/**\n * Tavily search response\n */\ninterface TavilySearchResponse {\n    query: string;\n    answer?: string;\n    results?: Array<{\n        title: string;\n        url: string;\n        content: string;\n        score: number;\n    }>;\n    response_time?: number;\n}\n\n/**\n * Tavily service for search endpoint\n * Transforms OpenAI-style requests to Tavily search format\n */\nexport class Tavily {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/tavily';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Perform a search using Tavily endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param endpoint - The Tavily endpoint to use (default: search)\n     * @returns Chat completion response in OpenAI format\n     */\n    async search(\n        request: ChatCompletionRequest,\n        endpoint: string = 'search'\n    ): Promise<ChatCompletionResponse> {\n        const url = `${this.baseUrl}/${endpoint}`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.config.apiKey}`,\n        };\n\n        // Extract query from last user message\n        const lastUserMessage = [...request.messages].reverse().find(m => m.role === 'user');\n        const query = lastUserMessage?.content || '';\n\n        const body = JSON.stringify({ query });\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body,\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Tavily request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const tavilyResponse = (await response.json()) as TavilySearchResponse;\n\n        // Transform Tavily response to OpenAI format\n        return this.transformToOpenAIFormat(tavilyResponse, `tavily/${endpoint}`);\n    }\n\n    /**\n     * Transform Tavily response to OpenAI format\n     */\n    private transformToOpenAIFormat(\n        tavilyResponse: TavilySearchResponse,\n        model: string\n    ): ChatCompletionResponse {\n        // Build content from Tavily response\n        let content = '';\n\n        if (tavilyResponse.answer) {\n            content = tavilyResponse.answer;\n        }\n\n        // Append search results if available\n        if (tavilyResponse.results && tavilyResponse.results.length > 0) {\n            if (content) content += '\\n\\n---\\n\\n**Sources:**\\n';\n            for (const result of tavilyResponse.results) {\n                content += `\\n- [${result.title}](${result.url})\\n  ${result.content.substring(0, 200)}...\\n`;\n            }\n        }\n\n        return {\n            id: `chatcmpl-tavily-${Date.now()}`,\n            object: 'chat.completion',\n            created: Math.floor(Date.now() / 1000),\n            model,\n            choices: [{\n                index: 0,\n                message: {\n                    role: 'assistant',\n                    content: content || 'No results found.',\n                },\n                finish_reason: 'stop',\n            }],\n        };\n    }\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n}\n","import type {\n  EternalAIConfig,\n  ChatCompletionRequest,\n  ChatCompletionStreamingRequest,\n  ChatCompletionNonStreamingRequest,\n  ChatCompletionChunk,\n  ChatCompletionResponse,\n} from '../types';\nimport { NanoBanana } from './nano-banana';\nimport { Tavily } from './tavily';\n\nconst NANO_BANANA_PREFIX = 'nano-banana/';\nconst TAVILY_PREFIX = 'tavily/';\n\ntype CustomProvider = 'nano-banana' | 'tavily' | null;\n\n/**\n * Chat service for sending messages and receiving responses\n */\nexport class Chat {\n  private readonly config: EternalAIConfig;\n  private readonly baseUrl = 'https://open.eternalai.org/api/v1';\n  private readonly nanoBanana: NanoBanana;\n  private readonly tavily: Tavily;\n\n  constructor(config: EternalAIConfig) {\n    this.config = config;\n    this.nanoBanana = new NanoBanana(config);\n    this.tavily = new Tavily(config);\n  }\n\n  /**\n   * Check if model uses a custom provider prefix and extract the actual model/endpoint name\n   * @param model - Model name that may include custom prefix like \"nano-banana/\" or \"tavily/\"\n   * @returns Object with provider type and extracted model name\n   */\n  private parseModelName(model: string): { provider: CustomProvider; modelName: string } {\n    if (model.startsWith(NANO_BANANA_PREFIX)) {\n      return {\n        provider: 'nano-banana',\n        modelName: model.slice(NANO_BANANA_PREFIX.length),\n      };\n    }\n    if (model.startsWith(TAVILY_PREFIX)) {\n      return {\n        provider: 'tavily',\n        modelName: model.slice(TAVILY_PREFIX.length),\n      };\n    }\n    return { provider: null, modelName: model };\n  }\n\n  /**\n   * Send a streaming chat completion request\n   * @param request - Chat completion request with stream: true, and optional image_config for image generation models\n   * @returns Async iterable of chat completion chunks\n   */\n  send(request: ChatCompletionStreamingRequest): Promise<AsyncIterable<ChatCompletionChunk>>;\n\n  /**\n   * Send a non-streaming chat completion request\n   * @param request - Chat completion request with stream: false or undefined, and optional image_config for image generation models\n   * @returns Chat completion response\n   */\n  send(request: ChatCompletionNonStreamingRequest): Promise<ChatCompletionResponse>;\n\n  /**\n   * Send a chat completion request\n   * @param request - Chat completion request with messages, model, stream option, and optional image_config for image generation models\n   * @returns Async iterable of chat completion chunks (if streaming) or single response\n   */\n  send(\n    request: ChatCompletionRequest\n  ): Promise<AsyncIterable<ChatCompletionChunk> | ChatCompletionResponse>;\n\n  /**\n   * Implementation of send method\n   */\n  async send(\n    request: ChatCompletionRequest\n  ): Promise<AsyncIterable<ChatCompletionChunk> | ChatCompletionResponse> {\n    // Check if model uses custom provider prefix\n    const { provider, modelName } = this.parseModelName(request.model);\n\n    // Route to custom providers\n    if (provider === 'nano-banana') {\n      if (request.stream) {\n        return this.nanoBanana.streamContent(request, modelName);\n      } else {\n        return this.nanoBanana.generateContent(request, modelName);\n      }\n    }\n\n    if (provider === 'tavily') {\n      // Tavily doesn't support streaming, always use non-streaming\n      return this.tavily.search(request, modelName);\n    }\n\n    // Standard EternalAI API request\n    const url = `${this.baseUrl}/chat/completions`;\n    const headers = {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${this.config.apiKey}`,\n    };\n\n    const body = JSON.stringify(request);\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body,\n      signal: this.createAbortSignal(),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`EternalAI request failed with status ${response.status}: ${errorText}`);\n    }\n\n    if (request.stream) {\n      // Check if body is readable before returning async iterable\n      if (!response.body) {\n        throw new Error('Response body is not readable');\n      }\n      return this.handleStreamingResponse(response);\n    } else {\n      return (await response.json()) as ChatCompletionResponse;\n    }\n  }\n\n  /**\n   * Create abort signal with timeout\n   */\n  private createAbortSignal(): AbortSignal | undefined {\n    if (this.config.timeout) {\n      const controller = new AbortController();\n      setTimeout(() => controller.abort(), this.config.timeout);\n      return controller.signal;\n    }\n    return undefined;\n  }\n\n  /**\n   * Handle streaming response using Server-Sent Events\n   */\n  private async *handleStreamingResponse(response: Response): AsyncIterable<ChatCompletionChunk> {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          const trimmedLine = line.trim();\n          if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n            continue;\n          }\n\n          if (trimmedLine.startsWith('data: ')) {\n            const data = trimmedLine.slice(6);\n            try {\n              const chunk = JSON.parse(data) as ChatCompletionChunk;\n              yield chunk;\n            } catch (error) {\n              // Silently skip invalid JSON chunks to maintain stream continuity\n              // In production, invalid chunks are typically malformed SSE data\n            }\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\n","import { Chat } from './services/chat';\nimport { NanoBanana } from './services/nano-banana';\nimport { Tavily } from './services/tavily';\nimport type { EternalAIConfig } from './types';\n\nexport class EternalAI {\n  public readonly chat: Chat;\n  public readonly nanoBanana: NanoBanana;\n  public readonly tavily: Tavily;\n  private readonly config: EternalAIConfig;\n\n  constructor(config: EternalAIConfig) {\n    if (!config.apiKey) {\n      throw new Error('API key is required');\n    }\n    this.config = config;\n    this.chat = new Chat(this.config);\n    this.nanoBanana = new NanoBanana(this.config);\n    this.tavily = new Tavily(this.config);\n  }\n}\n"]}
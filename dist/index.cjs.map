{"version":3,"sources":["../src/services/flux.ts","../src/services/glm.ts","../src/services/mistral.ts","../src/utils/image.ts","../src/services/nano-banana.ts","../src/services/tavily.ts","../src/services/uncensored-ai.ts","../src/services/wan.ts","../src/services/chat.ts","../src/client.ts"],"names":[],"mappings":"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","file":"index.cjs","sourcesContent":["import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n} from '../types';\n\n/**\n * Flux message content part\n */\ninterface FluxContentPart {\n    type: 'text' | 'image_url';\n    text?: string;\n    image_url?: {\n        url: string;\n        filename?: string;\n    };\n}\n\n/**\n * Flux message\n */\ninterface FluxMessage {\n    role: string;\n    content: string | FluxContentPart[];\n}\n\n/**\n * Flux image generation request options\n */\nexport interface FluxRequestOptions {\n    /** Image width in pixels (default: 1024) */\n    width?: number;\n    /** Image height in pixels (default: 1024) */\n    height?: number;\n    /** Safety tolerance level (0-6, default: 2) */\n    safety_tolerance?: number;\n}\n\n/**\n * Flux API request body\n */\ninterface FluxRequest {\n    prompt: string;\n    width: number;\n    height: number;\n    safety_tolerance: number;\n    /** First input image URL for image-to-image generation */\n    input_image?: string;\n    /** Second input image URL for reference */\n    input_image_2?: string;\n}\n\n/**\n * Flux generate response with polling URL\n */\nexport interface FluxGenerateResponse {\n    /** Request ID */\n    id: string;\n    /** URL to poll for results */\n    polling_url: string;\n    /** Cost of the request */\n    cost?: number;\n    /** Input megapixels */\n    input_mp?: number;\n    /** Output megapixels */\n    output_mp?: number;\n}\n\n/**\n * Flux result from polling\n */\nexport interface FluxResultResponse {\n    /** Request ID */\n    id: string;\n    /** Status: 'Pending', 'Running', 'Ready', 'Failed' */\n    status: 'Pending' | 'Running' | 'Ready' | 'Failed' | string;\n    /** Result data when status is Ready */\n    result?: {\n        /** Generation start time */\n        start_time?: number;\n        /** Original prompt */\n        prompt?: string;\n        /** Seed used for generation */\n        seed?: number;\n        /** Generated image URL */\n        sample?: string;\n    };\n    /** Progress information */\n    progress?: any;\n    /** Additional details */\n    details?: any;\n    /** Preview image */\n    preview?: string | null;\n    /** Error message if failed */\n    error?: string;\n}\n\n/**\n * Options for polling\n */\nexport interface PollingOptions {\n    /** Polling interval in milliseconds (default: 3000) */\n    interval?: number;\n    /** Maximum polling attempts (default: 60) */\n    maxAttempts?: number;\n    /** Callback for status updates */\n    onStatusUpdate?: (status: string, attempt: number) => void;\n}\n\n/**\n * Flux service for image generation\n * \n * Supported models:\n * - flux-2-pro: Professional quality image generation\n * - flux-2: Standard image generation\n */\nexport class Flux {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/flux/v1';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Generate image using Flux endpoint\n     * Returns polling_url immediately - use getResult() or pollResult() to poll for completion\n     * @param request - Chat completion request with prompt, model, and optional images\n     * @returns Generate response with polling_url for polling\n     * \n     * @example Text-to-Image\n     * ```typescript\n     * const task = await flux.generate({\n     *   messages: [{ role: 'user', content: 'A futuristic city at sunset' }],\n     *   model: 'flux/flux-2-pro',\n     *   width: 1920,\n     *   height: 1080,\n     *   safety_tolerance: 2\n     * });\n     * // Get polling_url and poll manually\n     * const result = await flux.getResult(task.polling_url);\n     * ```\n     * \n     * @example Image-to-Image with multiple references\n     * ```typescript\n     * const task = await flux.generate({\n     *   messages: [{ \n     *     role: 'user', \n     *     content: [\n     *       { type: 'text', text: 'Transform this image...' },\n     *       { type: 'image_url', image_url: { url: 'https://example.com/image1.jpg' } },\n     *       { type: 'image_url', image_url: { url: 'https://example.com/image2.jpg' } }\n     *     ] \n     *   }],\n     *   model: 'flux/flux-2-pro'\n     * });\n     * const result = await flux.pollResult(task.polling_url, {\n     *   onStatusUpdate: (status, attempt) => console.log(`[${attempt}] ${status}`)\n     * });\n     * ```\n     */\n    async generate(\n        request: ChatCompletionRequest & FluxRequestOptions\n    ): Promise<FluxGenerateResponse> {\n        // Extract model name (strip 'flux/' prefix if present)\n        const model = request.model.startsWith('flux/')\n            ? request.model.slice('flux/'.length)\n            : request.model;\n\n        const url = `${this.baseUrl}/${model}`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'accept': 'application/json',\n            'x-key': this.config.apiKey,\n        };\n\n        // Extract prompt and images from messages\n        let prompt = '';\n        const imageUrls: string[] = [];\n\n        for (const message of request.messages as FluxMessage[]) {\n            if (typeof message.content === 'string') {\n                prompt = message.content;\n            } else if (Array.isArray(message.content)) {\n                for (const part of message.content) {\n                    if (part.type === 'text') {\n                        prompt = part.text || '';\n                    } else if (part.type === 'image_url' && part.image_url) {\n                        imageUrls.push(part.image_url.url);\n                    }\n                }\n            }\n        }\n\n        // Build request body\n        const body: FluxRequest = {\n            prompt,\n            width: request.width ?? 1024,\n            height: request.height ?? 1024,\n            safety_tolerance: request.safety_tolerance ?? 2,\n        };\n\n        // Add input images if provided (max 2 images supported)\n        if (imageUrls.length > 0) {\n            body.input_image = imageUrls[0];\n        }\n        if (imageUrls.length > 1) {\n            body.input_image_2 = imageUrls[1];\n        }\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Flux request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const generateResponse = (await response.json()) as FluxGenerateResponse;\n\n        if (!generateResponse.polling_url) {\n            throw new Error('No polling_url in generate response');\n        }\n\n        // Return immediately - user calls getResult() or pollResult() to poll\n        return generateResponse;\n    }\n\n    /**\n     * Get result by polling URL\n     * @param pollingUrl - The polling URL returned from generate()\n     * @returns Result response with status and image URL\n     * \n     * @example\n     * ```typescript\n     * const result = await flux.getResult('https://api.eu2.bfl.ai/v1/get_result?id=xxx');\n     * if (result.status === 'Ready') {\n     *   console.log('Image URL:', result.result?.sample);\n     * }\n     * ```\n     */\n    async getResult(pollingUrl: string): Promise<FluxResultResponse> {\n        const headers = {\n            'Content-Type': 'application/json',\n            'accept': 'application/json',\n            'x-key': this.config.apiKey,\n        };\n\n        const response = await fetch(pollingUrl, {\n            method: 'GET',\n            headers,\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Flux getResult failed with status ${response.status}: ${errorText}`);\n        }\n\n        return (await response.json()) as FluxResultResponse;\n    }\n\n    /**\n     * Poll for result until completion or timeout\n     * @param pollingUrl - The polling URL returned from generate()\n     * @param options - Polling options (interval, maxAttempts, onStatusUpdate callback)\n     * @returns Final result response\n     * @throws Error if polling times out or request fails\n     * \n     * @example\n     * ```typescript\n     * const finalResult = await flux.pollResult('https://api.eu2.bfl.ai/v1/get_result?id=xxx', {\n     *   interval: 3000,\n     *   maxAttempts: 60,\n     *   onStatusUpdate: (status, attempt) => console.log(`[${attempt}] Status: ${status}`)\n     * });\n     * ```\n     */\n    async pollResult(\n        pollingUrl: string,\n        options: PollingOptions = {}\n    ): Promise<FluxResultResponse> {\n        const {\n            interval = 3000,\n            maxAttempts = 60,\n            onStatusUpdate,\n        } = options;\n\n        for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n            const result = await this.getResult(pollingUrl);\n\n            if (onStatusUpdate) {\n                console.log('pollingUrl', pollingUrl);\n                onStatusUpdate(result.status, attempt);\n            }\n\n            if (result.status === 'Ready') {\n                return result;\n            }\n\n            if (result.status === 'Failed') {\n                const message = result.error || 'Unknown error';\n                throw new Error(`Flux image generation failed: ${message}`);\n            }\n\n            // Wait before next poll (Pending or Running)\n            if (attempt < maxAttempts) {\n                await this.sleep(interval);\n            }\n        }\n\n        throw new Error(`Flux polling timed out after ${maxAttempts} attempts`);\n    }\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n\n    /**\n     * Sleep helper for polling\n     */\n    private sleep(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\n\n","import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n    ChatCompletionChunk,\n    ChatCompletionResponse,\n} from '../types';\n\n/**\n * GLM (ChatGLM) service for EternalAI's GLM API endpoint\n * Uses standard OpenAI-compatible format\n */\nexport class Glm {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/glm/api/paas/v4';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Generate content using GLM endpoint (non-streaming)\n     * @param request - Chat completion request in OpenAI format\n     * @param glmModel - The GLM model to use (default: glm-4.5-flash)\n     * @returns Chat completion response in OpenAI format\n     */\n    async generateContent(\n        request: ChatCompletionRequest,\n        glmModel: string = 'glm-4.5-flash'\n    ): Promise<ChatCompletionResponse> {\n        const url = `${this.baseUrl}/chat/completions`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'Accept-Language': 'en-US,en',\n            Authorization: `Bearer ${this.config.apiKey}`,\n        };\n\n        const body = {\n            ...request,\n            model: glmModel,\n            stream: false,\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`GLM request failed with status ${response.status}: ${errorText}`);\n        }\n\n        return (await response.json()) as ChatCompletionResponse;\n    }\n\n    /**\n     * Stream content using GLM endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param glmModel - The GLM model to use (default: glm-4.5-flash)\n     * @returns Async iterable of chat completion chunks\n     */\n    async *streamContent(\n        request: ChatCompletionRequest,\n        glmModel: string = 'glm-4.5-flash'\n    ): AsyncIterable<ChatCompletionChunk> {\n        const url = `${this.baseUrl}/chat/completions`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'Accept-Language': 'en-US,en',\n            Authorization: `Bearer ${this.config.apiKey}`,\n        };\n\n        const body = {\n            ...request,\n            model: glmModel,\n            stream: true,\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`GLM streaming request failed with status ${response.status}: ${errorText}`);\n        }\n\n        if (!response.body) {\n            throw new Error('Response body is not readable');\n        }\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || '';\n\n                for (const line of lines) {\n                    const trimmedLine = line.trim();\n                    if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n                        continue;\n                    }\n\n                    if (trimmedLine.startsWith('data: ')) {\n                        const data = trimmedLine.slice(6);\n                        try {\n                            const chunk = JSON.parse(data) as ChatCompletionChunk;\n                            yield chunk;\n                        } catch {\n                            // Skip invalid JSON chunks\n                        }\n                    }\n                }\n            }\n        } finally {\n            reader.releaseLock();\n        }\n    }\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n}\n","import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n    ChatCompletionChunk,\n    ChatCompletionResponse,\n} from '../types';\n\n/**\n * Mistral AI service for EternalAI's Mistral API endpoint\n * Uses standard OpenAI-compatible format\n */\nexport class Mistral {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/mistralai/v1';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Generate content using Mistral endpoint (non-streaming)\n     * @param request - Chat completion request in OpenAI format\n     * @param mistralModel - The Mistral model to use (default: devstral-2512)\n     * @returns Chat completion response in OpenAI format\n     */\n    async generateContent(\n        request: ChatCompletionRequest,\n        mistralModel: string = 'devstral-2512'\n    ): Promise<ChatCompletionResponse> {\n        const url = `${this.baseUrl}/chat/completions`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json',\n            Authorization: `Bearer ${this.config.apiKey}`,\n        };\n\n        const body = {\n            ...request,\n            model: mistralModel,\n            stream: false,\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Mistral request failed with status ${response.status}: ${errorText}`);\n        }\n\n        return (await response.json()) as ChatCompletionResponse;\n    }\n\n    /**\n     * Stream content using Mistral endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param mistralModel - The Mistral model to use (default: devstral-2512)\n     * @returns Async iterable of chat completion chunks\n     */\n    async *streamContent(\n        request: ChatCompletionRequest,\n        mistralModel: string = 'devstral-2512'\n    ): AsyncIterable<ChatCompletionChunk> {\n        const url = `${this.baseUrl}/chat/completions`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json',\n            Authorization: `Bearer ${this.config.apiKey}`,\n        };\n\n        const body = {\n            ...request,\n            model: mistralModel,\n            stream: true,\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Mistral streaming request failed with status ${response.status}: ${errorText}`);\n        }\n\n        if (!response.body) {\n            throw new Error('Response body is not readable');\n        }\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || '';\n\n                for (const line of lines) {\n                    const trimmedLine = line.trim();\n                    if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n                        continue;\n                    }\n\n                    if (trimmedLine.startsWith('data: ')) {\n                        const data = trimmedLine.slice(6);\n                        try {\n                            const chunk = JSON.parse(data) as ChatCompletionChunk;\n                            yield chunk;\n                        } catch {\n                            // Skip invalid JSON chunks\n                        }\n                    }\n                }\n            }\n        } finally {\n            reader.releaseLock();\n        }\n    }\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n}\n","/**\n * Upload base64 image to EternalAI storage\n * @param base64Data - Base64 encoded image data\n * @param mimeType - MIME type of the image (e.g., 'image/png')\n * @returns Public URL of the uploaded image\n */\nexport async function uploadImageToStorage(base64Data: string, mimeType: string): Promise<string> {\n    const uploadUrl = 'https://api.eternalai.org/api/agent/upload-image?admin_key=eai2024';\n\n    // Convert base64 to blob\n    const binaryData = Buffer.from(base64Data, 'base64');\n\n    // Create form data\n    const formData = new FormData();\n    const blob = new Blob([binaryData], { type: mimeType });\n    const filename = `${Date.now()}.${mimeType.split('/')[1] || 'png'}`;\n\n    formData.append('file', blob, filename);\n\n    const response = await fetch(uploadUrl, {\n        method: 'POST',\n        body: formData,\n    });\n\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Failed to upload image: ${response.status} - ${errorText}`);\n    }\n\n    const responseText = await response.text();\n\n    let result: { status?: number; data?: string };\n    try {\n        result = JSON.parse(responseText) as { status?: number; data?: string };\n    } catch (e) {\n        throw new Error(`Failed to parse upload response: ${responseText}`);\n    }\n\n    return result.data || '';\n}\n","import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n    ChatCompletionChunk,\n    ChatCompletionResponse,\n} from '../types';\nimport { uploadImageToStorage } from '../utils/image';\n\n/**\n * Response from Gemini-style API\n */\ninterface GeminiPart {\n    text?: string;\n    inlineData?: {\n        mimeType: string;\n        data: string; // base64 encoded\n    };\n}\n\ninterface GeminiCandidate {\n    content: {\n        parts: GeminiPart[];\n        role: string;\n    };\n    finishReason: string;\n}\n\ninterface GeminiResponse {\n    candidates: GeminiCandidate[];\n    usageMetadata?: {\n        promptTokenCount: number;\n        candidatesTokenCount: number;\n        totalTokenCount: number;\n    };\n}\n\n/**\n * NanoBanana service for custom endpoint models\n * Transforms OpenAI-style requests to Google Gemini format\n */\nexport class NanoBanana {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/nano-banana/v1beta/models';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Generate content using nano-banana endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param geminiModel - The Gemini model to use (default: gemini-2.5-flash-image)\n     * @returns Chat completion response in OpenAI format\n     */\n    async generateContent(\n        request: ChatCompletionRequest,\n        geminiModel: string = 'gemini-2.5-flash-image'\n    ): Promise<ChatCompletionResponse> {\n        const url = `${this.baseUrl}/${geminiModel}:generateContent`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'x-goog-api-key': this.config.apiKey,\n        };\n\n        // Transform OpenAI format to Gemini format\n        const geminiBody = await this.transformToGeminiFormat(request);\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(geminiBody),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`NanoBanana request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const geminiResponse = (await response.json()) as GeminiResponse;\n\n        // Transform Gemini response back to OpenAI format\n        return await this.transformToOpenAIFormat(geminiResponse, geminiModel);\n    }\n\n    /**\n     * Generate image content using nano-banana endpoint\n     * @param prompt - Text prompt for image generation\n     * @param geminiModel - The Gemini model to use (default: gemini-2.5-flash-image)\n     * @returns Base64 encoded image data or null if no image in response\n     */\n    async generateImage(\n        prompt: string,\n        geminiModel: string = 'gemini-2.5-flash-image'\n    ): Promise<{ mimeType: string; data: string } | null> {\n        const url = `${this.baseUrl}/${geminiModel}:generateContent`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'x-goog-api-key': this.config.apiKey,\n        };\n\n        const geminiBody = {\n            contents: [{\n                parts: [{ text: prompt }]\n            }]\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(geminiBody),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`NanoBanana request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const geminiResponse = (await response.json()) as GeminiResponse;\n\n        // Extract image from response\n        for (const candidate of geminiResponse.candidates || []) {\n            for (const part of candidate.content?.parts || []) {\n                if (part.inlineData) {\n                    return {\n                        mimeType: part.inlineData.mimeType,\n                        data: part.inlineData.data,\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Stream content using nano-banana endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param geminiModel - The Gemini model to use\n     * @returns Async iterable of chat completion chunks\n     */\n    async *streamContent(\n        request: ChatCompletionRequest,\n        geminiModel: string = 'gemini-2.5-flash-image'\n    ): AsyncIterable<ChatCompletionChunk> {\n        const url = `${this.baseUrl}/${geminiModel}:generateContent?alt=sse`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'x-goog-api-key': this.config.apiKey,\n        };\n\n        // Transform OpenAI format to Gemini format\n        const geminiBody = await this.transformToGeminiFormat(request);\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(geminiBody),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`NanoBanana streaming request failed with status ${response.status}: ${errorText}`);\n        }\n\n        if (!response.body) {\n            throw new Error('Response body is not readable');\n        }\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n        const chunkId = `chatcmpl-${Date.now()}`;\n        let streamChunkCount = 0;\n\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || '';\n\n                for (const line of lines) {\n                    const trimmedLine = line.trim();\n                    if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n                        continue;\n                    }\n\n                    if (trimmedLine.startsWith('data: ')) {\n                        const data = trimmedLine.slice(6);\n                        try {\n                            const geminiChunk = JSON.parse(data) as GeminiResponse;\n                            streamChunkCount++;\n\n                            // Check all parts for text and image data\n                            let content = '';\n                            const parts = geminiChunk.candidates?.[0]?.content?.parts || [];\n\n                            for (const part of parts) {\n                                if (part.text) {\n                                    content += part.text;\n                                } else if (part.inlineData) {\n                                    // Upload image and add URL to content\n                                    const imageUrl = await uploadImageToStorage(\n                                        part.inlineData.data,\n                                        part.inlineData.mimeType\n                                    );\n                                    content += imageUrl;\n                                }\n                            }\n\n                            const finishReason = geminiChunk.candidates?.[0]?.finishReason;\n\n                            const chunk: ChatCompletionChunk = {\n                                id: chunkId,\n                                object: 'chat.completion.chunk',\n                                created: Math.floor(Date.now() / 1000),\n                                model: geminiModel,\n                                choices: [{\n                                    index: 0,\n                                    delta: { content },\n                                    finish_reason: finishReason === 'STOP' ? 'stop' : null,\n                                }],\n                            };\n\n                            yield chunk;\n                        } catch {\n                            // Skip invalid JSON\n                        }\n                    }\n                }\n            }\n        } finally {\n            reader.releaseLock();\n        }\n    }\n\n    /**\n     * Transform OpenAI format request to Gemini format\n     */\n    private async transformToGeminiFormat(request: ChatCompletionRequest): Promise<object> {\n        const contents: { role: string; parts: any[] }[] = [];\n\n        for (const message of request.messages) {\n            // Map OpenAI roles to Gemini roles\n            let role = 'user';\n            if (message.role === 'assistant') {\n                role = 'model';\n            } else if (message.role === 'system') {\n                // Gemini doesn't have system role, prepend to first user message\n                // For now, treat as user\n                role = 'user';\n            }\n\n            const parts: any[] = [];\n\n            // Handle content as string or array\n            if (typeof message.content === 'string') {\n                parts.push({ text: message.content });\n            } else if (Array.isArray(message.content)) {\n                // Handle multimodal content (text + images)\n                for (const part of message.content) {\n                    if (part.type === 'text') {\n                        parts.push({ text: part.text });\n                    } else if (part.type === 'image_url') {\n                        // Convert image URL to base64 inline_data\n                        const imageUrl = part.image_url.url;\n                        const { mimeType, data } = await this.fetchImageAsBase64(imageUrl);\n                        parts.push({\n                            inline_data: {\n                                mime_type: mimeType,\n                                data: data,\n                            }\n                        });\n                    }\n                }\n            }\n\n            contents.push({\n                role,\n                parts,\n            });\n        }\n\n        return { contents };\n    }\n\n    /**\n     * Fetch image from URL and convert to base64\n     */\n    private async fetchImageAsBase64(url: string): Promise<{ mimeType: string; data: string }> {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch image from ${url}: ${response.status}`);\n        }\n\n        const arrayBuffer = await response.arrayBuffer();\n        const buffer = Buffer.from(arrayBuffer);\n        const base64 = buffer.toString('base64');\n\n        // Get mime type from response headers or default to image/jpeg\n        const mimeType = response.headers.get('content-type') || 'image/jpeg';\n\n        return { mimeType, data: base64 };\n    }\n\n    private async transformToOpenAIFormat(\n        geminiResponse: GeminiResponse,\n        model: string\n    ): Promise<ChatCompletionResponse> {\n        const candidate = geminiResponse.candidates?.[0];\n\n        // Check if response contains image data\n        let content = '';\n        for (const part of candidate?.content?.parts || []) {\n            if (part.text) {\n                content += part.text;\n            } else if (part.inlineData) {\n                // Upload base64 image to EternalAI storage and get URL\n                const imageUrl = await uploadImageToStorage(\n                    part.inlineData.data,\n                    part.inlineData.mimeType\n                );\n                content += imageUrl;\n            }\n        }\n\n        return {\n            id: `chatcmpl-${Date.now()}`,\n            object: 'chat.completion',\n            created: Math.floor(Date.now() / 1000),\n            model,\n            choices: [{\n                index: 0,\n                message: {\n                    role: 'assistant',\n                    content,\n                },\n                finish_reason: candidate?.finishReason === 'STOP' ? 'stop' : null,\n            }],\n            usage: geminiResponse.usageMetadata ? {\n                prompt_tokens: geminiResponse.usageMetadata.promptTokenCount,\n                completion_tokens: geminiResponse.usageMetadata.candidatesTokenCount,\n                total_tokens: geminiResponse.usageMetadata.totalTokenCount,\n            } : undefined,\n        };\n    }\n\n\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n}\n","import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n    ChatCompletionResponse,\n} from '../types';\n\n/**\n * Tavily search response\n */\ninterface TavilySearchResponse {\n    query: string;\n    answer?: string;\n    results?: Array<{\n        title: string;\n        url: string;\n        content: string;\n        score: number;\n    }>;\n    response_time?: number;\n}\n\n/**\n * Tavily service for search endpoint\n * Transforms OpenAI-style requests to Tavily search format\n */\nexport class Tavily {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/tavily';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Perform a search using Tavily endpoint\n     * @param request - Chat completion request in OpenAI format\n     * @param endpoint - The Tavily endpoint to use (default: search)\n     * @returns Chat completion response in OpenAI format\n     */\n    async search(\n        request: ChatCompletionRequest,\n        endpoint: string = 'search'\n    ): Promise<ChatCompletionResponse> {\n        const url = `${this.baseUrl}/${endpoint}`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.config.apiKey}`,\n        };\n\n        // Extract query from last user message\n        const lastUserMessage = [...request.messages].reverse().find(m => m.role === 'user');\n        const query = lastUserMessage?.content || '';\n\n        const body = JSON.stringify({ query });\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body,\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Tavily request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const tavilyResponse = (await response.json()) as TavilySearchResponse;\n\n        // Transform Tavily response to OpenAI format\n        return this.transformToOpenAIFormat(tavilyResponse, `tavily/${endpoint}`);\n    }\n\n    /**\n     * Transform Tavily response to OpenAI format\n     */\n    private transformToOpenAIFormat(\n        tavilyResponse: TavilySearchResponse,\n        model: string\n    ): ChatCompletionResponse {\n        // Build content from Tavily response\n        let content = '';\n\n        if (tavilyResponse.answer) {\n            content = tavilyResponse.answer;\n        }\n\n        // Append search results if available\n        if (tavilyResponse.results && tavilyResponse.results.length > 0) {\n            if (content) content += '\\n\\n---\\n\\n**Sources:**\\n';\n            for (const result of tavilyResponse.results) {\n                content += `\\n- [${result.title}](${result.url})\\n  ${result.content.substring(0, 200)}...\\n`;\n            }\n        }\n\n        return {\n            id: `chatcmpl-tavily-${Date.now()}`,\n            object: 'chat.completion',\n            created: Math.floor(Date.now() / 1000),\n            model,\n            choices: [{\n                index: 0,\n                message: {\n                    role: 'assistant',\n                    content: content || 'No results found.',\n                },\n                finish_reason: 'stop',\n            }],\n        };\n    }\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n}\n","import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n} from '../types';\n\n/**\n * Uncensored AI message content part\n */\ninterface UncensoredContentPart {\n    type: 'text' | 'image_url';\n    text?: string;\n    image_url?: {\n        url: string;\n        filename?: string;\n    };\n}\n\n/**\n * Uncensored AI message\n */\ninterface UncensoredMessage {\n    role: string;\n    content: string | UncensoredContentPart[];\n}\n\n/**\n * Uncensored AI request options (extended from ChatCompletionRequest)\n */\nexport interface UncensoredAIRequestOptions {\n    /** Type of generation: 'new' for text-to-image, 'edit' for image-to-image/video */\n    type?: 'new' | 'edit';\n    /** LoRA configuration for image generation (object format) */\n    lora_config?: Record<string, number>;\n    /** Image configuration (can be string or object) */\n    image_config?: string | Record<string, any>;\n    /** Video configuration (can be string or object) */\n    video_config?: string | Record<string, any>;\n    /** Enable magic prompt for video */\n    is_magic_prompt?: boolean;\n    /** Video duration in seconds */\n    duration?: number;\n    /** Enable audio in video */\n    audio?: boolean;\n}\n\n/**\n * Uncensored AI request body\n */\ninterface UncensoredRequest {\n    messages: UncensoredMessage[];\n    type?: string;\n    lora_config?: Record<string, number>;\n    image_config?: string;\n    video_config?: string;\n    is_magic_prompt?: boolean;\n    duration?: number;\n    audio?: boolean;\n}\n\n\n/**\n * Generate response with request_id for polling\n */\nexport interface UncensoredGenerateResponse {\n    request_id: string;\n    status: 'pending' | 'processing' | 'success' | 'failed' | 'error';\n    message?: string;\n}\n\n/**\n * Result response from polling endpoint\n */\nexport interface UncensoredResultResponse {\n    request_id: string;\n    status: 'pending' | 'processing' | 'success' | 'failed' | 'error';\n    result_url: string;\n}\n\n/**\n * Options for polling\n */\nexport interface PollingOptions {\n    /** Polling interval in milliseconds (default: 3000) */\n    interval?: number;\n    /** Maximum polling attempts (default: 60) */\n    maxAttempts?: number;\n    /** Callback for status updates */\n    onStatusUpdate?: (status: string, attempt: number) => void;\n}\n\n/**\n * UncensoredAI service for uncensored image/video generation and editing\n * \n * Supported endpoints:\n * - uncensored-image: For image generation (text-to-image, image-to-image)\n * - uncensored-video: For video generation from images\n */\nexport class UncensoredAI {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/uncensored-ai';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Generate or edit images/videos using Uncensored AI endpoint\n     * Returns request_id immediately - use getResult() or pollResult() to poll for completion\n     * @param request - Chat completion request with model, optional image content and additional options\n     * @returns Generate response with request_id for polling\n     * \n     * @example Text-to-Image\n     * ```typescript\n     * const task = await uncensoredAI.generate({\n     *   messages: [{ role: 'user', content: [{ type: 'text', text: 'A beautiful sunset' }] }],\n     *   model: 'uncensored-ai/uncensored-image',\n     *   type: 'new',\n     *   lora_config: { 'style-lora': 1 }\n     * });\n     * // Get request_id and poll manually\n     * const result = await uncensoredAI.getResult(task.request_id, 'uncensored-image');\n     * ```\n     * \n     * @example Image-to-Image\n     * ```typescript\n     * const task = await uncensoredAI.generate({\n     *   messages: [{ \n     *     role: 'user', \n     *     content: [\n     *       { type: 'text', text: 'Edit this image...' },\n     *       { type: 'image_url', image_url: { url: '...', filename: 'image.png' } }\n     *     ] \n     *   }],\n     *   model: 'uncensored-ai/uncensored-image',\n     *   type: 'edit',\n     *   image_config: { loras: ['skin', 'lightning'] }\n     * });\n     * ```\n     * \n     * @example Video Generation\n     * ```typescript\n     * const task = await uncensoredAI.generate({\n     *   messages: [{ \n     *     role: 'user', \n     *     content: [\n     *       { type: 'text', text: 'Animate this...' },\n     *       { type: 'image_url', image_url: { url: '...', filename: 'image.jpg' } }\n     *     ] \n     *   }],\n     *   model: 'uncensored-ai/uncensored-video',\n     *   type: 'edit',\n     *   is_magic_prompt: true,\n     *   duration: 5,\n     *   audio: true,\n     *   video_config: { is_fast_video: false, loras: ['flip', 'nsfw'] }\n     * });\n     * // Poll for video result\n     * const result = await uncensoredAI.pollResult(task.request_id, 'uncensored-video', {\n     *   interval: 5000,\n     *   maxAttempts: 120\n     * });\n     * ```\n     */\n    async generate(\n        request: ChatCompletionRequest & UncensoredAIRequestOptions\n    ): Promise<UncensoredGenerateResponse> {\n        // Extract endpoint from model (strip 'uncensored-ai/' prefix if present)\n        const endpoint = request.model.startsWith('uncensored-ai/')\n            ? request.model.slice('uncensored-ai/'.length)\n            : request.model;\n\n        const url = `${this.baseUrl}/${endpoint}`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'accept': 'application/json',\n            'x-api-key': this.config.apiKey,\n        };\n\n        // Build request body\n        const body: UncensoredRequest = {\n            messages: request.messages as UncensoredMessage[],\n        };\n\n        // Add type based on content (new = text-to-image, edit = image-to-image/video)\n        body.type = request.type !== undefined ? request.type : (request.messages as UncensoredMessage[]).find(message => (message.content as UncensoredContentPart[]).find(content => content.type === 'image_url')) ? 'edit' : 'new';\n\n        // Add lora_config if specified (for text-to-image)\n        if (request.lora_config) {\n            body.lora_config = request.lora_config;\n        }\n\n        // Add image_config if specified (for image-to-image)\n        if (request.image_config) {\n            body.image_config = typeof request.image_config === 'string'\n                ? request.image_config\n                : JSON.stringify(request.image_config);\n        }\n\n        // Add video_config if specified (for video generation)\n        if (request.video_config) {\n            body.video_config = typeof request.video_config === 'string'\n                ? request.video_config\n                : JSON.stringify(request.video_config);\n        }\n\n        // Add video-specific options\n        body.is_magic_prompt = request.is_magic_prompt !== undefined ? request.is_magic_prompt : true;\n\n        // Set default duration to 5 if not provided\n        body.duration = request.duration !== undefined ? request.duration : 5;\n\n        // Add audio if specified\n        body.audio = request.audio !== undefined ? request.audio : true;\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`UncensoredAI request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const uncensoredResponse = (await response.json()) as UncensoredGenerateResponse;\n\n        if (!uncensoredResponse.request_id) {\n            throw new Error('No request_id in generate response');\n        }\n\n        // Return immediately - user calls getResult() or pollResult() to poll\n        return uncensoredResponse;\n    }\n\n    /**\n     * Get result by request_id (polling endpoint)\n     * @param requestId - The request ID returned from generate()\n     * @param endpoint - The endpoint: 'uncensored-image' or 'uncensored-video'\n     * @returns Result response with status and content\n     * \n     * @example\n     * ```typescript\n     * const result = await uncensoredAI.getResult('req_123456', 'uncensored-image');\n     * if (result.status === 'completed') {\n     *   console.log('Image URL:', result.result?.url);\n     * }\n     * ```\n     */\n    async getResult(\n        requestId: string,\n        endpoint: string = 'uncensored-image'\n    ): Promise<UncensoredResultResponse> {\n        const url = `${this.baseUrl}/result/${endpoint}?request_id=${encodeURIComponent(requestId)}`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'accept': 'application/json',\n            'x-api-key': this.config.apiKey,\n        };\n\n        const response = await fetch(url, {\n            method: 'GET',\n            headers,\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`UncensoredAI getResult failed with status ${response.status}: ${errorText}`);\n        }\n\n        return (await response.json()) as UncensoredResultResponse;\n    }\n\n    /**\n     * Poll for result until completion or timeout\n     * @param requestId - The request ID returned from generate()\n     * @param endpoint - The endpoint: 'uncensored-image' or 'uncensored-video'\n     * @param options - Polling options (interval, maxAttempts, onStatusUpdate callback)\n     * @returns Final result response\n     * @throws Error if polling times out or request fails\n     * \n     * @example\n     * ```typescript\n     * const generateResponse = await uncensoredAI.generate({ ... }, 'uncensored-image');\n     * const requestId = JSON.parse(generateResponse.choices[0].message.content).request_id;\n     * \n     * const finalResult = await uncensoredAI.pollResult(requestId, 'uncensored-image', {\n     *   interval: 2000,\n     *   maxAttempts: 30,\n     *   onStatusUpdate: (status, attempt) => console.log(`[${attempt}] Status: ${status}`)\n     * });\n     * ```\n     */\n    async pollResult(\n        requestId: string,\n        endpoint: string = 'uncensored-image',\n        options: PollingOptions = {}\n    ): Promise<UncensoredResultResponse> {\n        const {\n            interval = 3000,\n            maxAttempts = 60,\n            onStatusUpdate,\n        } = options;\n\n        for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n            const result = await this.getResult(requestId, endpoint);\n\n            if (onStatusUpdate) {\n                console.log('requestId', requestId);\n                onStatusUpdate(result.status, attempt);\n            }\n\n            if (result.status === 'success') {\n                return result;\n            }\n\n            if (result.status === 'failed') {\n                throw new Error(`UncensoredAI request failed: ${result.status}`);\n            }\n\n            // Wait before next poll (pending or processing)\n            if (attempt < maxAttempts) {\n                await this.sleep(interval);\n            }\n        }\n\n        throw new Error(`UncensoredAI polling timed out after ${maxAttempts} attempts`);\n    }\n\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n\n    /**\n     * Sleep helper for polling\n     */\n    private sleep(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\n","import type {\n    EternalAIConfig,\n    ChatCompletionRequest,\n} from '../types';\n\n/**\n * Wan message content part\n */\ninterface WanContentPart {\n    type: 'text' | 'image_url';\n    text?: string;\n    image_url?: {\n        url: string;\n        filename?: string;\n    };\n}\n\n/**\n * Wan message\n */\ninterface WanMessage {\n    role: string;\n    content: string | WanContentPart[];\n}\n\n/**\n * Wan video generation request options\n */\nexport interface WanRequestOptions {\n    /** Video resolution (e.g., \"480P\", \"720P\", \"1080P\") */\n    resolution?: string;\n    /** Enable prompt extension for better results */\n    prompt_extend?: boolean;\n    /** Video duration in seconds */\n    duration?: number;\n    /** Enable audio in video */\n    audio?: boolean;\n}\n\n/**\n * Wan API request body\n */\ninterface WanRequest {\n    model: string;\n    input: {\n        prompt: string;\n        img_url?: string;\n    };\n    parameters: {\n        resolution: string;\n        prompt_extend: boolean;\n        duration: number;\n        audio: boolean;\n    };\n}\n\n/**\n * Wan async task response\n */\nexport interface WanTaskResponse {\n    output?: {\n        task_id: string;\n        task_status: string;\n    };\n    request_id?: string;\n}\n\n/**\n * Wan task result response\n */\nexport interface WanResultResponse {\n    output?: {\n        task_id: string;\n        task_status: 'PENDING' | 'RUNNING' | 'SUCCEEDED' | 'FAILED';\n        submit_time?: string;\n        scheduled_time?: string;\n        end_time?: string;\n        orig_prompt?: string;\n        actual_prompt?: string;\n        video_url?: string;\n        task_metrics?: {\n            TOTAL: number;\n            SUCCEEDED: number;\n            FAILED: number;\n        };\n        results?: Array<{\n            url: string;\n        }>;\n        code?: string;\n        message?: string;\n    };\n    usage?: {\n        duration: number;\n        video_count: number;\n        SR: number;\n    };\n    request_id?: string;\n}\n\n/**\n * Options for polling\n */\nexport interface PollingOptions {\n    /** Polling interval in milliseconds (default: 5000) */\n    interval?: number;\n    /** Maximum polling attempts (default: 120) */\n    maxAttempts?: number;\n    /** Callback for status updates */\n    onStatusUpdate?: (status: string, attempt: number) => void;\n}\n\n/**\n * Wan service for video generation from images\n * \n * Supported models:\n * - wan2.5-i2v-preview: Image-to-video generation\n */\nexport class Wan {\n    private readonly config: EternalAIConfig;\n    private readonly baseUrl = 'https://open.eternalai.org/wan/api/v1/services/aigc/video-generation';\n    private readonly tasksBaseUrl = 'https://open.eternalai.org/wan/api/v1/tasks';\n\n    constructor(config: EternalAIConfig) {\n        this.config = config;\n    }\n\n    /**\n     * Generate video from image using Wan endpoint\n     * Returns task_id immediately - use getResult() to poll for completion\n     * @param request - Chat completion request with prompt, image URL, and model\n     * @returns Task response with task_id for polling\n     * \n     * @example\n     * ```typescript\n     * // Start generation\n     * const task = await wan.generate({\n     *   messages: [{ \n     *     role: 'user', \n     *     content: [\n     *       { type: 'text', text: 'A dynamic graffiti art character...' },\n     *       { type: 'image_url', image_url: { url: 'https://...' } }\n     *     ] \n     *   }],\n     *   model: 'wan/wan2.5-i2v-preview',\n     *   resolution: '480P'\n     * });\n     * \n     * // Get task_id and poll manually\n     * const taskId = task.output?.task_id;\n     * const result = await wan.getResult(taskId);\n     * ```\n     */\n    async generate(\n        request: ChatCompletionRequest & WanRequestOptions\n    ): Promise<WanTaskResponse> {\n        const url = `${this.baseUrl}/video-synthesis`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'X-DashScope-Async': 'enable',\n            'Authorization': `Bearer ${this.config.apiKey}`,\n        };\n\n        // Extract model name (strip 'wan/' prefix if present)\n        const model = request.model.startsWith('wan/')\n            ? request.model.slice(4)\n            : request.model;\n\n        // Extract prompt and image URL from messages\n        let prompt = '';\n        let imgUrl: string | undefined;\n\n        for (const message of request.messages as WanMessage[]) {\n            if (typeof message.content === 'string') {\n                prompt = message.content;\n            } else if (Array.isArray(message.content)) {\n                for (const part of message.content) {\n                    if (part.type === 'text') {\n                        prompt = part.text || '';\n                    } else if (part.type === 'image_url' && part.image_url) {\n                        imgUrl = part.image_url.url;\n                    }\n                }\n            }\n        }\n\n        // Build request body\n        const body: WanRequest = {\n            model,\n            input: {\n                prompt,\n                ...(imgUrl && { img_url: imgUrl }),\n            },\n            parameters: {\n                resolution: request.resolution || '480P',\n                prompt_extend: request.prompt_extend !== undefined ? request.prompt_extend : true,\n                duration: request.duration !== undefined ? request.duration : 10,\n                audio: request.audio !== undefined ? request.audio : true,\n            },\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Wan request failed with status ${response.status}: ${errorText}`);\n        }\n\n        const taskResponse = (await response.json()) as WanTaskResponse;\n\n        if (!taskResponse.output?.task_id) {\n            throw new Error('No task_id in generate response');\n        }\n\n        // Return task response immediately - user calls getResult() to poll\n        return taskResponse;\n    }\n\n    /**\n     * Get result by task_id (polling endpoint)\n     * @param taskId - The task ID returned from generate()\n     * @returns Result response with status and video URL\n     * \n     * @example\n     * ```typescript\n     * const result = await wan.getResult('task_123456');\n     * if (result.output?.task_status === 'SUCCEEDED') {\n     *   console.log('Video URL:', result.output.results?.[0]?.url);\n     * }\n     * ```\n     */\n    async getResult(taskId: string): Promise<WanResultResponse> {\n        // DashScope uses /api/v1/tasks/{task_id} for checking task status\n        const url = `${this.tasksBaseUrl}/${encodeURIComponent(taskId)}`;\n\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.config.apiKey}`,\n        };\n\n        const response = await fetch(url, {\n            method: 'GET',\n            headers,\n            signal: this.createAbortSignal(),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Wan getResult failed with status ${response.status}: ${errorText}`);\n        }\n\n        return (await response.json()) as WanResultResponse;\n    }\n\n    /**\n     * Poll for result until completion or timeout\n     * @param taskId - The task ID returned from generate()\n     * @param options - Polling options (interval, maxAttempts, onStatusUpdate callback)\n     * @returns Final result response\n     * @throws Error if polling times out or request fails\n     * \n     * @example\n     * ```typescript\n     * const finalResult = await wan.pollResult('task_123456', {\n     *   interval: 5000,\n     *   maxAttempts: 120,\n     *   onStatusUpdate: (status, attempt) => console.log(`[${attempt}] Status: ${status}`)\n     * });\n     * ```\n     */\n    async pollResult(\n        taskId: string,\n        options: PollingOptions = {}\n    ): Promise<WanResultResponse> {\n        const {\n            interval = 5000,\n            maxAttempts = 120,\n            onStatusUpdate,\n        } = options;\n\n        for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n            const result = await this.getResult(taskId);\n\n            const status = result.output?.task_status || 'UNKNOWN';\n\n            if (onStatusUpdate) {\n                console.log('taskId', taskId);\n                onStatusUpdate(status, attempt);\n            }\n\n            if (status === 'SUCCEEDED') {\n                return result;\n            }\n\n            if (status === 'FAILED') {\n                const message = result.output?.message || 'Unknown error';\n                throw new Error(`Wan video generation failed: ${message}`);\n            }\n\n            // Wait before next poll (PENDING or RUNNING)\n            if (attempt < maxAttempts) {\n                await this.sleep(interval);\n            }\n        }\n\n        throw new Error(`Wan polling timed out after ${maxAttempts} attempts`);\n    }\n\n    /**\n     * Create abort signal with timeout\n     */\n    private createAbortSignal(): AbortSignal | undefined {\n        if (this.config.timeout) {\n            const controller = new AbortController();\n            setTimeout(() => controller.abort(), this.config.timeout);\n            return controller.signal;\n        }\n        return undefined;\n    }\n\n    /**\n     * Sleep helper for polling\n     */\n    private sleep(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\n","import type {\n  EternalAIConfig,\n  ChatCompletionRequest,\n  ChatCompletionStreamingRequest,\n  ChatCompletionNonStreamingRequest,\n  ChatCompletionChunk,\n  ChatCompletionResponse,\n} from '../types';\nimport { Flux } from './flux';\nimport { Glm } from './glm';\nimport { Mistral } from './mistral';\nimport { NanoBanana } from './nano-banana';\nimport { Tavily } from './tavily';\nimport { UncensoredAI } from './uncensored-ai';\nimport { Wan } from './wan';\n\nconst FLUX_PREFIX = 'flux/';\nconst GLM_PREFIX = 'glm/';\nconst MISTRAL_PREFIX = 'mistralai/';\nconst NANO_BANANA_PREFIX = 'nano-banana/';\nconst TAVILY_PREFIX = 'tavily/';\nconst UNCENSORED_AI_PREFIX = 'uncensored-ai/';\nconst WAN_PREFIX = 'wan/';\n\ntype CustomProvider = 'flux' | 'glm' | 'mistralai' | 'nano-banana' | 'tavily' | 'uncensored-ai' | 'wan' | null;\n\n/**\n * Chat service for sending messages and receiving responses\n */\nexport class Chat {\n  private readonly config: EternalAIConfig;\n  private readonly baseUrl = 'https://open.eternalai.org/api/v1';\n  private readonly flux: Flux;\n  private readonly glm: Glm;\n  private readonly mistral: Mistral;\n  private readonly nanoBanana: NanoBanana;\n  private readonly tavily: Tavily;\n  private readonly uncensoredAI: UncensoredAI;\n  private readonly wan: Wan;\n\n  constructor(config: EternalAIConfig) {\n    this.config = config;\n    this.flux = new Flux(config);\n    this.glm = new Glm(config);\n    this.mistral = new Mistral(config);\n    this.nanoBanana = new NanoBanana(config);\n    this.tavily = new Tavily(config);\n    this.uncensoredAI = new UncensoredAI(config);\n    this.wan = new Wan(config);\n  }\n\n  /**\n   * Check if model uses a custom provider prefix and extract the actual model/endpoint name\n   * @param model - Model name that may include custom prefix like \"nano-banana/\", \"tavily/\", or \"uncensored-ai/\"\n   * @returns Object with provider type and extracted model name\n   */\n  private parseModelName(model: string): { provider: CustomProvider; modelName: string } {\n    if (model.startsWith(FLUX_PREFIX)) {\n      return {\n        provider: 'flux',\n        modelName: model.slice(FLUX_PREFIX.length),\n      };\n    }\n    if (model.startsWith(GLM_PREFIX)) {\n      return {\n        provider: 'glm',\n        modelName: model.slice(GLM_PREFIX.length),\n      };\n    }\n    if (model.startsWith(MISTRAL_PREFIX)) {\n      return {\n        provider: 'mistralai',\n        modelName: model.slice(MISTRAL_PREFIX.length),\n      };\n    }\n    if (model.startsWith(NANO_BANANA_PREFIX)) {\n      return {\n        provider: 'nano-banana',\n        modelName: model.slice(NANO_BANANA_PREFIX.length),\n      };\n    }\n    if (model.startsWith(TAVILY_PREFIX)) {\n      return {\n        provider: 'tavily',\n        modelName: model.slice(TAVILY_PREFIX.length),\n      };\n    }\n    if (model.startsWith(UNCENSORED_AI_PREFIX)) {\n      return {\n        provider: 'uncensored-ai',\n        modelName: model.slice(UNCENSORED_AI_PREFIX.length),\n      };\n    }\n    if (model.startsWith(WAN_PREFIX)) {\n      return {\n        provider: 'wan',\n        modelName: model.slice(WAN_PREFIX.length),\n      };\n    }\n    return { provider: null, modelName: model };\n  }\n\n  /**\n   * Send a streaming chat completion request\n   * @param request - Chat completion request with stream: true, and optional image_config for image generation models\n   * @returns Async iterable of chat completion chunks\n   */\n  send(request: ChatCompletionStreamingRequest): Promise<AsyncIterable<ChatCompletionChunk>>;\n\n  /**\n   * Send a non-streaming chat completion request\n   * @param request - Chat completion request with stream: false or undefined, and optional image_config for image generation models\n   * @returns Chat completion response\n   */\n  send(request: ChatCompletionNonStreamingRequest): Promise<ChatCompletionResponse>;\n\n  /**\n   * Send a chat completion request\n   * @param request - Chat completion request with messages, model, stream option, and optional image_config for image generation models\n   * @returns Async iterable of chat completion chunks (if streaming) or single response\n   */\n  send(\n    request: ChatCompletionRequest\n  ): Promise<AsyncIterable<ChatCompletionChunk> | ChatCompletionResponse>;\n\n  /**\n   * Implementation of send method\n   */\n  async send(\n    request: ChatCompletionRequest\n  ): Promise<AsyncIterable<ChatCompletionChunk> | ChatCompletionResponse> {\n    // Check if model uses custom provider prefix\n    const { provider, modelName } = this.parseModelName(request.model);\n\n    // Route to custom providers\n    if (provider === 'flux') {\n      // Flux doesn't support streaming, always use non-streaming\n      // generate() returns polling_url, then pollResult() gets the image\n      const task = await this.flux.generate(request as any);\n      const pollingUrl = task.polling_url;\n\n      if (!pollingUrl) {\n        throw new Error('No polling_url returned from Flux generate');\n      }\n\n      // Poll for result with status updates\n      const result = await this.flux.pollResult(pollingUrl, {\n        interval: 3000,\n        maxAttempts: 60,\n        onStatusUpdate: (status: string) => {\n          console.log('Flux status update:', status);\n        },\n      });\n\n      // Transform FluxResultResponse to ChatCompletionResponse\n      const imageUrl = result.result?.sample || '';\n\n      return {\n        id: result.id || `chatcmpl-flux-${Date.now()}`,\n        object: 'chat.completion',\n        created: Math.floor(Date.now() / 1000),\n        model: request.model,\n        choices: [{\n          index: 0,\n          message: {\n            role: 'assistant',\n            content: imageUrl,\n          },\n          finish_reason: 'stop',\n        }],\n      };\n    }\n\n    if (provider === 'glm') {\n      if (request.stream) {\n        return this.glm.streamContent(request, modelName);\n      } else {\n        return this.glm.generateContent(request, modelName);\n      }\n    }\n\n    if (provider === 'mistralai') {\n      if (request.stream) {\n        return this.mistral.streamContent(request, modelName);\n      } else {\n        return this.mistral.generateContent(request, modelName);\n      }\n    }\n\n    if (provider === 'nano-banana') {\n      if (request.stream) {\n        return this.nanoBanana.streamContent(request, modelName);\n      } else {\n        return this.nanoBanana.generateContent(request, modelName);\n      }\n    }\n\n    if (provider === 'tavily') {\n      // Tavily doesn't support streaming, always use non-streaming\n      return this.tavily.search(request, modelName);\n    }\n\n    if (provider === 'uncensored-ai') {\n      // UncensoredAI doesn't support streaming, always use non-streaming\n      // generate() returns request_id, then pollResult() gets the result\n      const task = await this.uncensoredAI.generate(request);\n      const requestId = task.request_id;\n\n      if (!requestId) {\n        throw new Error('No request_id returned from UncensoredAI generate');\n      }\n\n      // Determine endpoint for polling\n      const endpoint = modelName; // 'uncensored-image' or 'uncensored-video'\n      const isVideo = endpoint === 'uncensored-video';\n\n      // Poll for result with appropriate intervals\n      const result = await this.uncensoredAI.pollResult(requestId, endpoint, {\n        interval: isVideo ? 5000 : 3000,\n        maxAttempts: isVideo ? 120 : 60,\n        onStatusUpdate: (status: string) => {\n          console.log('UncensoredAI status update:', status);\n        },\n      });\n\n      // Transform UncensoredResultResponse to ChatCompletionResponse\n      const resultUrl = result.result_url;\n\n      return {\n        id: result.request_id || `chatcmpl-uncensored-${Date.now()}`,\n        object: 'chat.completion',\n        created: Math.floor(Date.now() / 1000),\n        model: request.model,\n        choices: [{\n          index: 0,\n          message: {\n            role: 'assistant',\n            content: resultUrl,\n          },\n          finish_reason: 'stop',\n        }],\n      };\n    }\n\n    if (provider === 'wan') {\n      // Wan doesn't support streaming, always use non-streaming\n      // generate() returns task_id, then pollResult() gets the video\n      const task = await this.wan.generate(request);\n      const taskId = task.output?.task_id;\n\n      if (!taskId) {\n        throw new Error('No task_id returned from Wan generate');\n      }\n\n      // Poll for result with status updates\n      const result = await this.wan.pollResult(taskId, {\n        onStatusUpdate: (status: string) => {\n          console.log('Wan status update:', status);\n        },\n      });\n\n      // video_url is directly in output, or fallback to results[0].url for backward compatibility\n      const videoUrl = result.output?.video_url || result.output?.results?.[0]?.url || '';\n\n      return {\n        id: result.request_id || `chatcmpl-wan-${Date.now()}`,\n        object: 'chat.completion',\n        created: Math.floor(Date.now() / 1000),\n        model: request.model,\n        choices: [{\n          index: 0,\n          message: {\n            role: 'assistant',\n            content: videoUrl,\n          },\n          finish_reason: 'stop',\n        }],\n      };\n    }\n\n    // Standard EternalAI API request\n    const url = `${this.baseUrl}/chat/completions?from=ts-sdk`;\n    const headers = {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${this.config.apiKey}`,\n    };\n\n    const body = JSON.stringify(request);\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body,\n      signal: this.createAbortSignal(),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`EternalAI request failed with status ${response.status}: ${errorText}`);\n    }\n\n    if (request.stream) {\n      // Check if body is readable before returning async iterable\n      if (!response.body) {\n        throw new Error('Response body is not readable');\n      }\n      return this.handleStreamingResponse(response);\n    } else {\n      return (await response.json()) as ChatCompletionResponse;\n    }\n  }\n\n  /**\n   * Create abort signal with timeout\n   */\n  private createAbortSignal(): AbortSignal | undefined {\n    if (this.config.timeout) {\n      const controller = new AbortController();\n      setTimeout(() => controller.abort(), this.config.timeout);\n      return controller.signal;\n    }\n    return undefined;\n  }\n\n  /**\n   * Handle streaming response using Server-Sent Events\n   */\n  private async *handleStreamingResponse(response: Response): AsyncIterable<ChatCompletionChunk> {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          const trimmedLine = line.trim();\n          if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n            continue;\n          }\n\n          if (trimmedLine.startsWith('data: ')) {\n            const data = trimmedLine.slice(6);\n            try {\n              const chunk = JSON.parse(data) as ChatCompletionChunk;\n              yield chunk;\n            } catch (error) {\n              // Silently skip invalid JSON chunks to maintain stream continuity\n              // In production, invalid chunks are typically malformed SSE data\n            }\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\n","import { Chat } from './services/chat';\nimport { Flux } from './services/flux';\nimport { NanoBanana } from './services/nano-banana';\nimport { Tavily } from './services/tavily';\nimport { UncensoredAI } from './services/uncensored-ai';\nimport { Wan } from './services/wan';\nimport type { EternalAIConfig } from './types';\n\nexport class EternalAI {\n  public readonly chat: Chat;\n  public readonly flux: Flux;\n  public readonly nanoBanana: NanoBanana;\n  public readonly tavily: Tavily;\n  public readonly uncensoredAI: UncensoredAI;\n  public readonly wan: Wan;\n  private readonly config: EternalAIConfig;\n\n  constructor(config: EternalAIConfig) {\n    if (!config.apiKey) {\n      throw new Error('API key is required');\n    }\n    this.config = config;\n    this.chat = new Chat(this.config);\n    this.flux = new Flux(this.config);\n    this.nanoBanana = new NanoBanana(this.config);\n    this.tavily = new Tavily(this.config);\n    this.uncensoredAI = new UncensoredAI(this.config);\n    this.wan = new Wan(this.config);\n  }\n}\n"]}